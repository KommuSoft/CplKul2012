% !TEX root = dslreport.tex

\subsection{Database}
We've chosen for a PostgreSQL as database management system. We prefered this system because we had some experience with it, we have a PostgreSQL available online and there is a .NET provider for it.

The database contains the following tables.
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth ]{../../../Databasemodel/Database.png}
	\caption{Het overzicht van de database.}
	\label{fig:database_design}
\end{figure}
In every entity, the column \texttt{id} is the primary key of the table. There are also some other constraints, for example: the \texttt{code} of the \texttt{airline}, \texttt{airplane} and \texttt{airport} should be unique. Also some constraints to make the database consistent are present, for example: the combination of a \texttt{flight} and \texttt{seat} should be unique in a table \texttt{booking}. 

We can do two things with data from the database. We can put data in the database or we can fetch data from the database. First we will describe how we can fetch data from the database.

Each table of the database has a corresponding class in \Csh. This class represents the  data. Such a class has also a request class. The request class is the one you need to get the data from the database. An example should make things more clear. We have the class \texttt{Airport} and the class \texttt{AirportRequest}. An \texttt{Airport} has 6 properties: \texttt{ID}, \texttt{code}, \texttt{name}, \texttt{country}, \texttt{city} and  \texttt{company}. These properties correspond with the columns of the the table \texttt{airport} (see figure \ref{fig:database_design}). The class \texttt{AirportRequest} has the following method \texttt{List<Airport> fetchAirportFromCityName (string cityName)}. This method returns every airport that is located in a city with the given name. This request class contains several "fetch" methods. Some of these methods are inspired on the request classes from the adapter part. Others are just provided to help other methods, e.g. \texttt{List<Airport> fetchAirportFromID(int ID)}. The request class contains also another interesting method, namely \texttt{string toQuery (Airport airport)}. This method creates a query that should return the given parameter. This way we are able to create subqueries.

Insert information into the database is done in the class that has the same name as the table. If we use the airport example, we see that the \texttt{Airport} class has multiple constructors. One has as parameter every column of the table \texttt{airport}, another one has as parameter every column except the id. There are alse some constructors where some arguments are optional.
A last one has as parameter an  \texttt{IDataReader}. This one is needed for fetching data from the database, so we are only interested in the first two ones. Because the \texttt{id} of an \texttt{airport} is of the type \texttt{serial} we don't have to provide the id. If a user prefers an id, she/he can try to use it with the first constructor. The constructor only creates a \Csh object, so there won't be a check if the id already exists. When we want to insert it in the database we still have to call the insert function. This function will check if the object is valid and if so the object will be inserted into the database. The checks if the object is valid are done in the method \texttt{bool isValid (out string exceptionMessage)}. When the object isn't valid \texttt{false} is returned and an explaination is provided in the parameter \texttt{exceptionMessage}. The insertion itself is pretty straigthforward because the attributes of the class are most of the times a one-to-one mapping to the columns of the table. Sometimes some basic parsing is needed.

Consistency checking happens at different levels, we've already discussed that some consistency checking happens at the level of the adapter. In the database frontend there is also some consistency checking. The consistency checking happens in the method \texttt{isValid} method. This method checks if every property of the element that will be inserted in the database is valid. Also this method checks if the code of an airline has the correct specifications, i.e. a 2 or 3 letter capital code. There is also consistency checking in the database. As already mentioned the database has also some constraints on the columns, e.g. some columns may not contain a \texttt{NULL} or the values in some columns should be unique. The advantage of checking at the database level is that we are completely sure that the database is in a consistent state. However the exception messages of the database can be cryptic, therefore checking at a higher level can be more useful. Also we are more familiar with writing checks in a programming language like \Csh than writing constraints for the database. We see that the consistency checking happens at every different levels in the DSL. This has the advantage that we can use the most easy place to write our consistency checks. Also some checks happens a couple of times, this isn't a real problem. In fact it can be desirable if we want to use another user interface or another database.