% !TEX root = dslreport.tex

\subsection{Database}
We've chosen for a PostgreSQL as database management system. We prefered this system because we had some experience with it, we have a PostgreSQL available online and there is a .NET provider for it.

The database contains the following tables.
\begin{figure}
	\centering
	\includegraphics[width=\textwidth ]{../../../Databasemodel/Database.png}
\end{figure}
%TODO figuurtje maken

We can do two things with data from the database. We can put data in the database or we can fetch data from the database. First we will describe how we can fetch data from the database.

Each table of the database has a corresponding class in \Csh. This class represents the  data. Such a class has also a request class. The request class is the one you need to get the data from the database. An example should make things more clear. We have the class \texttt{Airport} and the class \texttt{AirportRequest}. An \texttt{Airport} has 6 properties: \texttt{ID}, \texttt{code}, \texttt{name}, \texttt{country}, \texttt{city} and  \texttt{company}. These properties correspond with the columns of the the table \texttt{airport} (see figure \ref{fig:database_design}). The class \texttt{AirportRequest} has the following method \texttt{List<Airport> fetchAirportFromCityName (string cityName)}. This method returns every airport that is located in a city with the given name. This request class contains several "fetch" methods. Some of these methods are inspired on the request classes from the adapter part. Others are just provided to help other methods, e.g. \texttt{List<Airport> fetchAirportFromID(int ID)}. The request class contains also another interesting method, namely \texttt{string toQuery (Airport airport)}. This method creates a query that should return the given parameter. This way we are able to create subqueries.

Insert information into the database is done in the class that has the same name as the table. If we use the airport example, we see that the \texttt{Airport} class has multiple constructors. One has as parameter every column of the table \texttt{airport}, another one has as parameter every column except the id. There are alse some constructors where some arguments are optional.
A last one has as parameter an  \texttt{IDataReader}. This one is needed for fetching data from the database, so we are only interested in the first two ones. Because the \texttt{id} of an \texttt{airport} is of the type \texttt{serial} we don't have to provide the id. If a user prefers an id, she/he can try to use it with the first constructor. The constructor only creates a \Csh object, so there won't be a check if the id already exists. When we want to insert it in the database we still have to call the insert function. This function will check if the object is valid and if so the object will be inserted into the database. The checks if the object is valid are done in the method \texttt{bool isValid (out string exceptionMessage)}. When the object isn't valid \texttt{false} is returned and an explaination is provided in the parameter \texttt{exceptionMessage}. The insertion itself is pretty straigthforward because the attributes of the class are most of the times a one-to-one mapping to the columns of the table. Sometimes some basic parsing is needed. There is one important remark to make. Consistency checking happens at two levels, the first one is in the \texttt{isValid} method, the other one happens in the database. The database has also some constraints on the columns, e.g. some columns may not contain a \texttt{NULL}. The advantage of checking at the database level is that we are completely sure that the database is in a consistent state. However the exception messages of the database can be cryptic, therefore checking at a higher level can be more useful. Also we are more familiar with writing checks in a programming language like \Csh than writing constraints for the database.